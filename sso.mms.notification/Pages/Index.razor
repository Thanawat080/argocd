@page "/notification"
@using Blazored.LocalStorage;
@using sso.mms.helper.Configs;
@using sso.mms.login.Services;
@using sso.mms.login.ViewModels;
@using sso.mms.notification.Services;

@using sso.mms.helper.Components.Navbar;
@using sso.mms.helper.Utility;
@using System.Threading
@using sso.mms.helper.PortalModel;
@using sso.mms.helper.ViewModels;
@using System.IdentityModel.Tokens.Jwt;
@inject ILocalStorageService _localstorage;
@inject ReadTokenService readTokenService
@inject NotificationService notificationService;
@inject UserRoleService userRoleService

<style>
    @@media only screen and (min-width: 1000px) {
        .pm-xl {
            position: fixed;
            width: 100%;
            z-index: 1000;
        }
    }

    @@media only screen and (max-width: 1000px) {
        .position-class {
            position: relative
        }
    }

</style>

@if (isLoading == true)
{
    <style>body { overflow: hidden; }</style><LoadingPage></LoadingPage>
}

<NavbarLoginSSO PageCode="HOP0401" Fname="@getUser?.FirstName" Lname="@getUser?.LastName" responseNotiM="@responseNotiM"></NavbarLoginSSO>


<MediaStyle></MediaStyle>
<div style="display:none">
    <div>short token @shortToken</div>
    <div>access token @responseShortToken?.accessToken</div>
    <div>refresh token @responseShortToken?.refreshToken</div>
</div>

<div class="bg-noti">
    <div class="px-body" style="margin-top: 1rem;">
        <div class="row">
            <div class="col-md-12 col-lg-6 col-xl-3 mb-2">
                <div class="col">
                    <NotificationCategories responseNotiM="@responseNotiM" OnChangeListNotiT="@GetNotificationT" />
                </div>
            </div>
            <div class="col-md-12 col-lg-6 col-xl-3 mb-2">
                <div class="col">
                    <NotificationList responseNotiT="@responseNotiT" OnChangeListNotiT="@GetContentNotiT" />
                </div>
            </div>
            <div class="col-md-12 col-lg-12 col-xl-6 mb-2">
                <NotificationDetail contentNotiT="@contentNotiT" responseNotiM="@responseNotiM" />
            </div>
        </div>
    </div>
</div>
<div>
    <Footer />
</div>


@code {
    [Parameter]
    [SupplyParameterFromQuery(Name = "token")]
    public string? shortToken { get; set; } = "";
    private CancellationTokenSource cancellationTokenSource;
    private bool isContinuousWorkRunning;
    private bool isLoading = false;
    private List<NotiM>? responseNotiM = new List<NotiM>();
    private List<NotiT>? responseNotiT = new List<NotiT>();
    private NotiT? contentNotiT = new NotiT();
    private int? updateStatusNotiT = 0;
    private ResponseLogin getUser { get; set; } = null!;
    private ResponseShortToken responseShortToken { get; set; } = null!;
    private int notiNo;
    public string? env = ConfigureCore.ConfigENV;
    public string? url;

    public UserRole userRole;
    public List<string>? roleCodeList = new List<string>();
    public string orgCode = "";
    public string username = "";
    public string userType = "";
    public List<NotiT>? appNotiT = new List<NotiT>();
    public NotiTApiModel notiTapi = new NotiTApiModel();
    private List<NotiM>? responseNoti = new List<NotiM>();

    protected override async Task OnInitializedAsync()
    {
        isLoading = true;

        url = ConfigureCore.redirectNotification;

        responseShortToken = await readTokenService.ReadToken(shortToken!);

        if (responseShortToken != null)
        {
            Console.WriteLine("ResponseShortToken", responseShortToken);
            isLoading = false;
            JwtSecurityTokenHandler tokenHandler = new JwtSecurityTokenHandler();
            JwtSecurityToken jwt = tokenHandler.ReadJwtToken(responseShortToken.accessToken);
            var token = jwt.Payload.ToList();
            KeyValuePair<string, object> result = token.FirstOrDefault(pair => pair.Key == "preferred_username");
            KeyValuePair<string, object> resultRealm = token.FirstOrDefault(pair => pair.Key == "iss");
            userType = resultRealm.Value.ToString().Split('/').Last();
            username = result.Value.ToString();
            userRole = await userRoleService.GetRoleByUserName(username);
            orgCode = await userRoleService.GetHospitalCode(username);

            await _localstorage.SetItemAsync("userRole", userRole);
            await _localstorage.SetItemAsync("userType", userType);
            await _localstorage.SetItemAsync("orgCode", orgCode);

            if(userRole != null)
            {
                roleCodeList = userRole.role.Select(roleObject => roleObject.roleCode).ToList();
            }

            await _localstorage.SetItemAsync("roleCodeList", roleCodeList);
            notiTapi = new NotiTApiModel
            {
                userType = userType,
                username = username,
                orgCode = orgCode,
                roleCodeList = roleCodeList
            };
            responseNoti = await notificationService.GetNotiByUser(notiTapi);
            if (responseNoti != null)
            {
                foreach (var item in responseNoti)
                {
                    notiNo = notiNo + item.NotificationTs.Count;
                }
            }
        }

        await FetchGetNotificationM();

        if (responseNotiM != null)
        {
            Console.WriteLine(responseNotiM[7]);
            await GetNotificationT(responseNotiM.Where(x => x.Sequence == 1).FirstOrDefault().Id);
            StateHasChanged();
        }
        foreach (var clidkId in responseNotiM)
        {
            if (clidkId.Id == 8)
            {
                clidkId.DivClass = "clicked";
            }

        }

        getUser = await _localstorage.GetItemAsync<ResponseLogin>("userdata");
        isLoading = false;


    }

    private async Task StartContinuousWork()
    {
        if (!isContinuousWorkRunning)
        {
            isContinuousWorkRunning = true;
            cancellationTokenSource = new CancellationTokenSource();

            await Task.Run(async () =>
            {
                while (!cancellationTokenSource.Token.IsCancellationRequested)
                {
                    await InvokeAsync(FetchGetNotificationM);
                    //StateHasChanged();
                    await Task.Delay(TimeSpan.FromSeconds(5));
                }
            });
        }
    }

    private void StopContinuousWork()
    {
        if (isContinuousWorkRunning)
        {
            cancellationTokenSource.Cancel();
            isContinuousWorkRunning = false;
        }
    }

    private async Task GetNotificationT(int notiMId)
    {
        responseNotiT = await notificationService.GetNotificationTByUser(notiMId, notiTapi);

        StateHasChanged();
    }

    private async Task GetContentNotiT(int notiTId)
    {
        contentNotiT = await notificationService.GetContentNotiT(notiTId);
        if (contentNotiT != null)
        {
            //var isSuccess = await notificationService.UpdateStatusNotiT(notiTId, 0);
            var notiLog = new NotificationLog
                {
                    NotiTId = notiTId,
                    CreateBy = notiTapi.username,
                    UpdateBy = notiTapi.username
                };
            var isSuccess = await notificationService.AddNotificationLog(notiLog);
            if (isSuccess)
            {
                updateStatusNotiT = responseNotiT.FirstOrDefault(item => item.Id == notiTId).NotiMId;
            }
            await FetchGetNotificationM();
            StateHasChanged();
        }
    }

    private async Task FetchGetNotificationM()
    {

        responseNotiM = await notificationService.GetNotiByUser(notiTapi);
        foreach (var item in responseNotiM)
        {
            if (item.Id == updateStatusNotiT)
            {
                item.DivClass = "clicked";
            }
            else
            {
                item.DivClass = "";
            }
        }
        StateHasChanged();
        //await Task.Delay(1000);
    }
}